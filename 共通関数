Option Explicit ' 未定義の変数は使用できないように


Public Const BNAME_SOURCE As String = "C:\me\unten\マクロいろいろ.xlsm"
Public Const workDir As String = "C:\me\unten\OperationSummary"
Public Const BNAME_MATOME As String = "\\saclaopr18.spring8.or.jp\common\運転状況集計\最新\SACLA\SACLA運転状況集計まとめ.xlsm"


'OLD
'Public Const BNAME_SOURCE As String = "C:\Users\kenichi\Dropbox\gitdir\VBA運転集計用\マクロいろいろ.xlsm"
'Public Const workDir As String = "C:\Users\kenichi\Documents\OperationSummary"







'ブックを開く ==============================================================================================================================
'リモートサーバー上のファイルを開く際、開くのに時間がかかっているためにタイミングの問題でエラーが発生している可能性があります。この場合、待機時間を設けて再試行することで、エラーを回避できることがあります。以下の方法で、指定された時間待機しながらエラーを再試行するコードを実装できます。
Function OpenBook(ByVal WorkBookName As String) As Workbook
    Debug.Print "Debug   Start..............................................................................................."
    Dim OWB As Workbook
    Dim wb As Workbook
    Dim retryCount As Integer
    retryCount = 3  ' 再試行の回数

    ' 開いているブックの中に指定されたパスのブックがあるかを確認
    For Each wb In Workbooks
       Debug.Print "Debug   wb.Name =  " & wb.Name & " は開かれています"
       If wb.FullName = WorkBookName Then
           Set OWB = wb
           Debug.Print "Debug   OpenBook.Name =  [" & OWB.Name & "] は既に開かれています"
           Exit For
       End If
    Next wb
    
    On Error Resume Next
    If OWB Is Nothing Then
        Do While retryCount > 0
            Set OWB = Workbooks.Open(WorkBookName, ReadOnly:=False)
            If Err.Number = 0 Then Exit Do  ' 正常に開けたらループを抜ける
            Debug.Print "エラーが発生しました。再試行します。残り再試行回数: " & retryCount - 1
            Err.Clear
            retryCount = retryCount - 1
            Application.Wait Now + TimeValue("0:00:05")  ' 5秒待機
        Loop

        ' 最後にエラーが残っている場合の対応
        If Err.Number <> 0 Then
            MsgBox "ブックが見つからないか、開けませんでした。エラー番号: " & Err.Number & vbCrLf & _
                   "エラーメッセージ: " & Err.Description & vbCrLf & _
                   "ファイル名やパスを確認してください: " & WorkBookName, vbExclamation
            Set OWB = Nothing
            Err.Clear
        Else
            Debug.Print "Debug   OpenBook.Name =  [" & OWB.Name & "] を開きました"
        End If
    End If
    On Error GoTo 0  ' エラーハンドリング解除
    
    Set OpenBook = OWB
    Debug.Print "Debug   OpenBook Finish"
End Function









' 使ってない
Function OpenBookOLD(ByVal WorkBookName As String) As Workbook
    Debug.Print "Debug   ブックを開きます。-----------  " & WorkBookName
    Dim OWB As Workbook
    Dim wb As Workbook
    
    ' 開いているブックの中に指定されたパスのブックがあるかを確認
    For Each wb In Workbooks
       'Debug.Print "Debug   wb.Name =  " & wb.Name & " は開かれています"
       If wb.FullName = WorkBookName Then
           Set OWB = wb
           Debug.Print "Debug   OpenBook.Name =  [" & OWB.Name & "] は既に開かれています"
           Exit For
       End If
    Next wb
    
    ' エラーハンドリング開始
    On Error Resume Next
    If OWB Is Nothing Then
        ' 指定したブックが開かれていない場合、新たに開こうとする
        Set OWB = Workbooks.Open(WorkBookName, ReadOnly:=False) ' SACLA運転状況集計BL*.xlsm　を開こうとすると、なぜかエラーが発生するので以下コメントアウトした
'        If Err.Number <> 0 Then
'            ' エラーが発生した場合、エラーメッセージを表示
'            MsgBox "ブックが見つからないか、開けませんでした。エラー番号: " & Err.Number & vbCrLf & _
'                   "エラーメッセージ: " & Err.Description & vbCrLf & _
'                   "ファイル名やパスを確認してください: " & WorkBookName, vbExclamation
'            Set OWB = Nothing  ' エラー発生時は Nothing を返す
'            Err.Clear
'        Else
'            Debug.Print "Debug   OpenBook.Name =  [" & OWB.Name & "] を開きました"
'        End If
        Debug.Print "Debug   OpenBook.Name =  [" & OWB.Name & "] を開きました  開けていない可能性あり　エラー処理をパスしてるので"
    End If
    On Error GoTo 0  ' エラーハンドリング解除
    
    ' 関数の戻り値として設定
    Set OpenBook = OWB
    
    Debug.Print "Debug   OpenBook Finish"
End Function





'========================================================================================================
Sub Cleanup()
    MsgBox "何らかのエラーが発生が発生しました"
    Call Fin
End Sub



Sub Fin()
    MsgBox "終了処理"
'    ActiveWindow.Zoom = 100
    Application.ExecuteExcel4Macro "SHOW.TOOLBAR(""Ribbon"",True)"
    Application.DisplayFullScreen = False
    ' 開いているすべてのブックをループ
    Dim wb As Workbook
    For Each wb In Workbooks
        ' 各ブックのウィンドウに対してズームを設定
        wb.Windows(1).Zoom = 100
    Next wb
    End
End Sub





'指定さてた文字列が存在する行を取得==============================================================================================================================
Function getLineNum(ByVal str As String, ByVal TARGET_COL As Integer, ByVal sheetname As Worksheet) As Integer
    
    For i = 1 To sheetname.Cells(Rows.Count, TARGET_COL).End(xlUp).Row
        'Debug.Print "getLineNum　行番号: " & i & "   line_cnt = " & line_cnt & "    Value: " & Cells(i, 2).Value
        If sheetname.Cells(i, TARGET_COL).Value = str Then '
            getLineNum = i
            Exit For
        End If
    Next

End Function


'シート存在を確認==============================================================================================================================
Function SheetExists(wb As Workbook, sname As String) As Boolean
    On Error Resume Next ' エラーが発生しても処理を継続
    Dim ws As Worksheet
    Set ws = wb.Sheets(sname) ' 指定したシートをセット
    SheetExists = Not ws Is Nothing ' シートが存在すればTrue
    Debug.Print "@SheetExists   Sheetname: [" & sname & "]  " & SheetExists
    On Error GoTo 0 ' エラーハンドリングをリセット
End Function





'シート存在を確認 Not Use ==============================================================================================================================
Function flgExsistSheet(ByVal WorkSheetName As String) As Boolean
Dim sht As Worksheet
  For Each sht In ActiveWorkbook.Worksheets
    If sht.Name = WorkSheetName Then
        flgExsistSheet = True
        Exit Function
    End If
  Next sht
flgExsistSheet = False
End Function




'==============================================================================================================================
Sub RunBatchFile(batchFilePath As String)

    ' バッチファイルのパスが指定されているか確認
    If batchFilePath = "" Then
        MsgBox "バッチファイルのパスを指定してください", vbExclamation
        Exit Sub
    End If
    
    ' Shell関数でバッチファイルを実行
    shell batchFilePath, vbNormalFocus
End Sub





